import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as o,o as a}from"./app-2H1Ylti7.js";const i={};function p(s,e){return a(),t("div",null,[...e[0]||(e[0]=[o('<h1 id="异步编程方案" tabindex="-1"><a class="header-anchor" href="#异步编程方案"><span>异步编程方案</span></a></h1><h2 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数"><span>回调函数</span></a></h2><p>回调函数不会造成回调地狱, 但是多层回调函数嵌套, 可能造成回调地狱</p><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>Promise</span></a></h2><p>promise解决了多层回调函数嵌套, 可能导致的回调地狱问题<br> 在语法上, promise是一个对象, 代表一个异步操作. promise有三个状态, pending, resolved, rejected, 初始状态为pending待兑现, 当状态从pending变为resolved后, 状态会凝固, 可以使用.then方法获取异步操作成功后的兑现值. 当状态从pending变为rejected后, 状态会凝固, 可以使用.catch方法, 获取异步操作失败后的原因.</p><p>promise的缺点是, 创建后会立即执行, 无法中途取消, 且当promise状态未发生变化时, 不知道内部运行情况. .then方法中是单独作用域</p><h5 id="常见的promise静态方法" tabindex="-1"><a class="header-anchor" href="#常见的promise静态方法"><span>常见的promise静态方法:</span></a></h5><p>Promise.all(), 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的promise, 当所有输入的promise的状态都被兑现后, 返回的promise也会被兑现, 并返回一个包含所有兑现值的数组; 当输入的promise中, 有一个被拒绝, 返回的promise也会被拒绝, 返回这个被拒绝的原因.</p><p>Promise.Race, 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的Promise, 它会随着第一个Promise状态的敲定而敲定</p><p>Promise.allsetted, 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的Promise, 当所有输入的Promise的状态都被敲定后, 返回的promise会被兑现, 并返回一个对象数组,每个对象都描述了相对应输入promise的状态</p><p>这三种方法, 返回的promise状态被敲定后, 输入的promise还会接着执行</p><h2 id="generator函数" tabindex="-1"><a class="header-anchor" href="#generator函数"><span>generator函数</span></a></h2><p>提供了一种新的异步编程的解决思路, 可以使用next方法, 一步步执行函数, 解决了.then方法中变量不共享问题, 但是代码很复杂</p><h2 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await"><span>async await</span></a></h2><p>是generator函数的语法糖, await 后的返回值是 promise对象</p>',15)])])}const c=r(i,[["render",p]]),d=JSON.parse('{"path":"/posts/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88.html","title":"异步编程方案","lang":"zh-CN","frontmatter":{"description":"异步编程方案 回调函数 回调函数不会造成回调地狱, 但是多层回调函数嵌套, 可能造成回调地狱 Promise promise解决了多层回调函数嵌套, 可能导致的回调地狱问题 在语法上, promise是一个对象, 代表一个异步操作. promise有三个状态, pending, resolved, rejected, 初始状态为pending待兑现, ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"异步编程方案\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-21T04:03:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"frank.js\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Variable-Frank/posts/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88.html"}],["meta",{"property":"og:site_name","content":"变量弗兰克"}],["meta",{"property":"og:title","content":"异步编程方案"}],["meta",{"property":"og:description","content":"异步编程方案 回调函数 回调函数不会造成回调地狱, 但是多层回调函数嵌套, 可能造成回调地狱 Promise promise解决了多层回调函数嵌套, 可能导致的回调地狱问题 在语法上, promise是一个对象, 代表一个异步操作. promise有三个状态, pending, resolved, rejected, 初始状态为pending待兑现, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-21T04:03:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-21T04:03:23.000Z"}]]},"git":{"createdTime":1758427403000,"updatedTime":1758427403000,"contributors":[{"name":"xuqi","username":"xuqi","email":"zhangxuqi2001@163.com","commits":1,"url":"https://github.com/xuqi"}]},"readingTime":{"minutes":1.86,"words":559},"filePathRelative":"posts/JavaScript/异步编程方案.md","excerpt":"\\n<h2>回调函数</h2>\\n<p>回调函数不会造成回调地狱, 但是多层回调函数嵌套, 可能造成回调地狱</p>\\n<h2>Promise</h2>\\n<p>promise解决了多层回调函数嵌套, 可能导致的回调地狱问题<br>\\n在语法上, promise是一个对象, 代表一个异步操作. promise有三个状态, pending, resolved, rejected, 初始状态为pending待兑现, 当状态从pending变为resolved后, 状态会凝固, 可以使用.then方法获取异步操作成功后的兑现值. 当状态从pending变为rejected后, 状态会凝固, 可以使用.catch方法, 获取异步操作失败后的原因.</p>","autoDesc":true}');export{c as comp,d as data};
