import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as r}from"./app-qIylsfBC.js";const i={};function o(s,a){return r(),e("div",null,[...a[0]||(a[0]=[n('<h1 id="javascript实现继承的方式" tabindex="-1"><a class="header-anchor" href="#javascript实现继承的方式"><span>JavaScript实现继承的方式</span></a></h1><h2 id="原型链继承" tabindex="-1"><a class="header-anchor" href="#原型链继承"><span>原型链继承</span></a></h2><h3 id="详细" tabindex="-1"><a class="header-anchor" href="#详细"><span>详细</span></a></h3><ol><li>子类构造函数的原型指向父类构造函数的实例, 可以继承父类原型上的属性和方法, 父类实例上的属性和方法</li><li><strong>继承的引用类型的属性是共享的</strong>, 修改内容会影响所有实例, 且<strong>在创建子类实例时, 不能像父类构造函数传参</strong>, 但是继承的基本类型的属性, 修改内容会在自身上新创建这个属性, 不会造成变量污染</li></ol><h2 id="借用构造函数继承" tabindex="-1"><a class="header-anchor" href="#借用构造函数继承"><span>借用构造函数继承</span></a></h2><h3 id="详细-1" tabindex="-1"><a class="header-anchor" href="#详细-1"><span>详细</span></a></h3><ol><li>需要把想要继承的属性和方法都定义在父类构造函数里, 在子类构造函数里调用父类构造函数, 当使用new关键字, 调用子类构造函数时, 会创建一个新的对象, 并将子类构造函数的原型赋值给这个新创建的对象, 接着子类构造函数的this指向这个新创建的对象, 父类构造函数的this通过显式绑定比如call,apply 指向新创建的对象, 然后执行子构造函数的函数体</li><li>可以像父类构造函数传参, 继承的引用类型和基本类型的属性都不会共享, 但是<strong>继承的函数只能定义在父类的构造函数里, 每个子类实例都拥有相同的方法,但是地址不同, 不能复用</strong></li></ol><h2 id="组合式继承" tabindex="-1"><a class="header-anchor" href="#组合式继承"><span>组合式继承</span></a></h2><h3 id="详细-2" tabindex="-1"><a class="header-anchor" href="#详细-2"><span>详细</span></a></h3><ol><li>借用构造函数继承父类的属性, 原型链继承父类原型上的方法, 但是缺点是调用了两次构造函数 <strong>(父类构造函数的逻辑执行了两次,浪费性能)</strong>, 会继承父类实例上多余的属性</li></ol><h2 id="寄生组合式继承" tabindex="-1"><a class="header-anchor" href="#寄生组合式继承"><span>寄生组合式继承</span></a></h2><h3 id="详细-3" tabindex="-1"><a class="header-anchor" href="#详细-3"><span>详细</span></a></h3><ol><li>借用构造函数继承父类的属性, 通过定义寄生函数继承父类的原型</li></ol>',13)])])}const l=t(i,[["render",o]]),c=JSON.parse('{"path":"/posts/JavaScript/%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.html","title":"JavaScript实现继承的方式","lang":"zh-CN","frontmatter":{"description":"JavaScript实现继承的方式 原型链继承 详细 子类构造函数的原型指向父类构造函数的实例, 可以继承父类原型上的属性和方法, 父类实例上的属性和方法 继承的引用类型的属性是共享的, 修改内容会影响所有实例, 且在创建子类实例时, 不能像父类构造函数传参, 但是继承的基本类型的属性, 修改内容会在自身上新创建这个属性, 不会造成变量污染 借用构造函...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript实现继承的方式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-21T04:03:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"frank.js\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Variable-Frank/posts/JavaScript/%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"变量弗兰克"}],["meta",{"property":"og:title","content":"JavaScript实现继承的方式"}],["meta",{"property":"og:description","content":"JavaScript实现继承的方式 原型链继承 详细 子类构造函数的原型指向父类构造函数的实例, 可以继承父类原型上的属性和方法, 父类实例上的属性和方法 继承的引用类型的属性是共享的, 修改内容会影响所有实例, 且在创建子类实例时, 不能像父类构造函数传参, 但是继承的基本类型的属性, 修改内容会在自身上新创建这个属性, 不会造成变量污染 借用构造函..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-21T04:03:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-21T04:03:23.000Z"}]]},"git":{"createdTime":1758427403000,"updatedTime":1758427403000,"contributors":[{"name":"xuqi","username":"xuqi","email":"zhangxuqi2001@163.com","commits":1,"url":"https://github.com/xuqi"}]},"readingTime":{"minutes":1.65,"words":494},"filePathRelative":"posts/JavaScript/实现继承方式.md","excerpt":"\\n<h2>原型链继承</h2>\\n<h3>详细</h3>\\n<ol>\\n<li>子类构造函数的原型指向父类构造函数的实例, 可以继承父类原型上的属性和方法, 父类实例上的属性和方法</li>\\n<li><strong>继承的引用类型的属性是共享的</strong>, 修改内容会影响所有实例, 且<strong>在创建子类实例时, 不能像父类构造函数传参</strong>, 但是继承的基本类型的属性, 修改内容会在自身上新创建这个属性, 不会造成变量污染</li>\\n</ol>\\n<h2>借用构造函数继承</h2>\\n<h3>详细</h3>\\n<ol>\\n<li>需要把想要继承的属性和方法都定义在父类构造函数里, 在子类构造函数里调用父类构造函数, 当使用new关键字, 调用子类构造函数时, 会创建一个新的对象, 并将子类构造函数的原型赋值给这个新创建的对象, 接着子类构造函数的this指向这个新创建的对象, 父类构造函数的this通过显式绑定比如call,apply 指向新创建的对象, 然后执行子构造函数的函数体</li>\\n<li>可以像父类构造函数传参, 继承的引用类型和基本类型的属性都不会共享, 但是<strong>继承的函数只能定义在父类的构造函数里, 每个子类实例都拥有相同的方法,但是地址不同, 不能复用</strong></li>\\n</ol>","autoDesc":true}');export{l as comp,c as data};
