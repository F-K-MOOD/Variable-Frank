
# 异步编程方案

## 回调函数
回调函数不会造成回调地狱, 但是多层回调函数嵌套, 可能造成回调地狱

## Promise
promise解决了多层回调函数嵌套, 可能导致的回调地狱问题
在语法上, promise是一个对象, 代表一个异步操作. promise有三个状态, pending, resolved, rejected, 初始状态为pending待兑现, 当状态从pending变为resolved后, 状态会凝固, 可以使用.then方法获取异步操作成功后的兑现值. 当状态从pending变为rejected后, 状态会凝固, 可以使用.catch方法, 获取异步操作失败后的原因.

promise的缺点是, 创建后会立即执行, 无法中途取消, 且当promise状态未发生变化时, 不知道内部运行情况. .then方法中是单独作用域

##### 常见的promise静态方法:
Promise.all(), 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的promise, 当所有输入的promise的状态都被兑现后, 返回的promise也会被兑现, 并返回一个包含所有兑现值的数组; 当输入的promise中, 有一个被拒绝, 返回的promise也会被拒绝, 返回这个被拒绝的原因.

Promise.Race, 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的Promise, 它会随着第一个Promise状态的敲定而敲定

Promise.allsetted, 这是Promise的静态方法, 它接受一个Promise可迭代对象作为输入, 并返回一个新的Promise, 当所有输入的Promise的状态都被敲定后, 返回的promise会被兑现, 并返回一个对象数组,每个对象都描述了相对应输入promise的状态

这三种方法, 返回的promise状态被敲定后, 输入的promise还会接着执行



## generator函数
提供了一种新的异步编程的解决思路, 可以使用next方法, 一步步执行函数, 解决了.then方法中变量不共享问题, 但是代码很复杂

## async await
是generator函数的语法糖, await 后的返回值是 promise对象

