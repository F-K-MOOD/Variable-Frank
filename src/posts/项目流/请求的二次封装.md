## 请求的二次封装

### 基础配置

配置**baseUrl**, **timeout**, **headers**

### 第一层请求拦截器, 响应拦截器

在请求拦截器中, **headers**中注入 token,
在响应拦截器中, 做**token**失效, **权限不足**, **接口不存在**等错误的统一处理, 比如

- 响应状态码为 401,表示 token 失效,跳转到登录页面.
- 响应状态码为 403,表示权限不足,跳转到首页.
- 响应状态码为 404,表示接口不存在,跳转到 404 页面

### 第二层请求拦截器, 响应拦截器

前提, 根据 config 生成请求的唯一的 id, id = url+method+params+data, 创建一个**map**, key 为 **id**,value 为 **取消请求的函数**
在请求拦截器中处理重复请求, 具体来说如果 map 中存在 id, 则取消之前的请求, 然后将当前请求加入 map
在响应拦截器里, 取消请求, 删除响应成功后的 map 中的 id 和响应失败后的 map 中的 id

### 注意点

Map 和对象进行键的搜索和属性的删除, 时间复杂度都是 O(1), 那为什么使用 map 而不是使用 Map 呢?
主要还是考虑到 map 的键的安全性, 因为 map 的键会保留类型也不会进行隐式转换, 然后 map 的 api 更加语义化,比如 has, set.

还有一个 map 的使用场景就是封装错误响应状态码的映射表, 比如
new map([
400, '参数错误',
401, '未登录',
403, '无权限',
404, '接口不存在',
500, '服务器错误'
])
