## 浏览器渲染进程

### 浏览器有很多进程, 与前端相关的是渲染 render 进程, 这个进程下有很多线程

- **gui 渲染线程**, 负责解析 HTML、CSS，构建 DOM 树、CSSOM 树，布局和绘制页面
- **javascript 引擎线程**, 负责执行 js 脚本
- **网络线程**, 处理网络资源请求，如 HTML、CSS、JS 文件的下载
- **事件触发线程**, 管理事件循环，将用户交互、定时器等事件加入任务队列
- **定时触发线程**, 管理 setTimeout、setInterval 等定时任务
- **合成图层**, 负责将各个图层合成到一起

### 页面渲染完整过程(线程协作版)

#### 阶段一：网络请求与解析准备

1. 用户输入 URL → 浏览器进程接收 → 通知网络线程
2. 网络线程发起 HTTP 请求 → 下载 HTML 文档
3. 下载完成后 → 将 HTML 数据传递给渲染进程的主线程

#### 阶段二：DOM 构建与资源发现

- 解析 HTML 字节流 → 构建 DOM 树
- 遇到 link 标签 → 通知网络线程下载 CSS（不阻塞 DOM 构建）
- 遇到/script 标签 → 分类处理

  情况 A：普通 script（无 async/defer）

  - 暂停 DOM 构建
  - 等待网络线程下载 JS
  - JS 下载完成后立即执行（阻塞 GUI 线程）

  情况 B：async script

  - 异步下载，不阻塞 DOM 构建
  - 下载完成后立即执行（可能中断当前渲染）

  情况 C：defer script

  - 异步下载，不阻塞 DOM 构建
  - 等待 DOM 构建完成后再执行

#### 阶段三 样式计算与布局

- 所有 CSS 下载完成后 → 解析 CSS 规则 → 构建 CSSOM 树
- 合并 DOM 树和 CSSOM 树 → 生成渲染树（Render Tree）

6. 布局计算（Layout/Reflow）：
   - 计算每个**渲染树节点的位置和大小**
   - 生成布局树（Layout Tree）

#### 阶段五：图层分层与绘制指令

7. 图层管理：

- 根据 **z-index、transform** 等属性将布局树分层
- 生成**图层树**（Layer Tree）
- 为每个图层生成绘制指令列表（Paint Records）

8. **_主线程将图层树和绘制指令提交给合成线程_**

#### 阶段六：光栅化与合成

9. 合成线程接收主线程提交的数据：

- 将每个图层的绘制指令分发给光栅化线程池

10. 光栅化线程工作：
    - 将矢量绘制指令转换为位图像素
    - 处理视口内和附近区域的图块（Tiles）
11. 合成线程收集所有光栅化完成的图块：
    - 按照**图层顺序**合成最终图像
    - 通过 IPC 将最终帧提交给浏览器进程

#### 阶段七： 显示与后续更新

12. 浏览器进程将合成好的帧发送给 GPU 进程
13. GPU 进程通过图形 API 将图像显示到屏幕上

14. 后续更新机制：
    - 事件触发线程监控用户交互
    - 定时器线程管理 setTimeout/setInterval
    - 当需要更新时，重新回到阶段三开始渲染流程

### 线程与性能优化

1. js 引擎线程和渲染线程是互斥的, 也就是说在执行 js 脚本的时候, 渲染线程是不执行的, 为了防止堵塞页面渲染, 可以使用 defer 或者 async 属性, 让 js 脚本延迟加载. 再使用 vuecli 或者 vite 等构建工具进行开发时, 会自动处理脚本加载顺序, 但是我们可以使用**路由懒加载, 进行分割代码, 减少初始代码体积**
2. 如果后端返回了很多条数据, 一下全部渲染到页面上, 会造成页面卡顿, 这是因为用户的设备大部分是 60Hz 的, 也就是一秒钟要渲染 60 次, 两次渲染的时间间隔是 16.66ms, 可能出现的两种情况：
   **_JS 执行时间超过 16.66ms_**：GUI 渲染线程根本没能开始执行，浏览器直接跳过当前帧的渲染
   **_JS 执行时间虽未超时，但剩余时间不足完成渲染_**：比如 JS 执行了 15ms，虽然 GUI 线程可以开始工作，但渲染管线需要 8ms，总时间 23ms 仍然超过 16.66ms 的帧预算，导致无法在下一帧刷新前完成渲染
3. transform 和 opcity 属性会创建新的图层, 当这些属性发生变化时, 不会重新进行布局, 而是利用 gpu 加速,在合成线程中完成图形变换
4. 利用 will-change 属性, 可以提前告知浏览器, 页面即将发生的变化, 这样浏览器可以提前准备好相应的资源, 避免页面闪烁
